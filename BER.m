%This script generates a bitstream for a predetermined CW message and
%compares it against a thresholded, recorded data sequence.

%y = abs(loadFile('data.dat'));
%y = resample(y,5,4);

%Part 1: generate CW message
%inputSeq = input("CW Message: ", 's') %in between letters: 3 dots. Words: 7 dots.
inputSeq = "W2KGY";
inputSeq = upper(inputSeq);
morse_seq = [".----","..---","...--","....-",".....","-....","--...","---..","----.","-----",".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."];  

charseq = ['1','2','3','4','5','6','7','8','9','0','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'];

charnum = 0;
input_morse = [];
for k=1:length(inputSeq)
   for g=1:length(charseq)
       if strcmp(charseq(g),inputSeq(k)) == 1
       input_morse = [input_morse morse_seq(g)]
       end
   end 
end

%now convert to vector where dot = 1, dash = 111

dot = 1;
dash = [1 1 1];
morse_stream = [];
clear k
for k=1:length(input_morse)
   
    morse_char = char(input_morse(k));
    for m=1:length(morse_char)
        if morse_char(m) == '-'
            morse_stream = [morse_stream dash]
        end
        if morse_char(m) == '.'
            morse_stream = [morse_stream dot]
        end
        morse_stream = [morse_stream 0]
    end
        
morse_stream = [morse_stream 0 0 0];
end

tt = 1:(2*length(morse_stream));
f = 500;
signal = zeros(1,length(morse_stream));
for k=1:length(tt)
    if mod(tt(k), 2) == 0 %even number
    signal(k) = morse_stream(k/2)* cos(2*pi*f * tt(k));
    else
    signal(k) = morse_stream(k/2 + .5)* cos(2*pi*f * tt(k));
    end
end

%plot(signal)

%Now for BER


%Threshold it


%plot(y)

%The signal is relatively static so you can make cisual assumptions about
%it. Steps to do:

%{
1. Get '2D' Model into 1D, where it resembles more of a 1-0 wave. Or
convert base signal into that one. Eliminate offset of 3?
2. Determine length of dot
3. threshold according to that. Maybe just involves downsampling until you
get what you need?
4. BER - I would honestly just XOR between signal you have and captured
signal. Pretty graph with overlay?

%}

aa = y - 3;
%plot(aa)

windowSize = 20; 
b = (1/windowSize)*ones(1,windowSize);
a = 10;

aa = filter(b,a,aa);
aa = aa( aa>=0 );
u = ones(1,1000);
w = conv(u,aa);

w = w -30;

H = zeros(1,length(w));
for i=1:length(w)
    if -.25 < w(i) & .25 > w(i)
    H(i) = 1;
    end
        
end



L = 10000;
Fs = 4e6;
f = Fs*(0:(L/2))/L;
Y = fft(w);
P2 = abs(Y/L);
P1 = P2(1:L/2+1);
P1(2:end-1) = 2*P1(2:end-1);


HH = H(4e6:6e6);

mean(HH(70600:1219000))
mean(HH(546800:698700))
%{
morse_out = zeros(1,round(length(H)/150000));
clear i
for i=1:length(morse_out)
    word_size = 50000
    if (i*word_size+word_size) < length(H) 
    chunk = H(i*word_size:(i*word_size+word_size));
    
    if mean(chunk) > 0.02
        morse_out(i) = 1;
    end    
    end
end

%}

G = H(1:3:end);

windowSize = 1; 
c = 1;
d = 1;
G = filter(d,c,G);
%H = filter(b,1,H);

figure(1)
tiledlayout(3,1)
nexttile
plot(w)
title('Filtered CW Test Signal')
xlabel('timestep (samples)')
ylabel('Relative Amplitude')
nexttile
plot(f,P1) 
title('Single-Sided Amplitude Spectrum of X(t)')
xlabel('f (Hz)')
ylabel('|P1(f)|')
nexttile
plot(H)
title('Thresholded CW Data')


